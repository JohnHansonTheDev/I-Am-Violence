<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>globalvar useflashlight;
useflashlight=0;

surf=surface_create(2640,2480);
surface_set_target(surf);
draw_clear(c_black);
surface_reset_target();

postsurf=surface_create(2640,2480);
surface_set_target(postsurf);
draw_clear(c_black);
surface_reset_target();



spr_srf=-1;

step=0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (spr_srf)
    sprite_delete(spr_srf);
    
    
surface_free(postsurf)
surface_free(surf)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string></string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>instance_destroy()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="76">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string></string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="73">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//heaviest performance bottleneck

if( useflashlight==1)exit

returningToNormal = 0;

if (mainObject3.state == "dead" || bulletTime==1 ) {
    if( bulletTime == 1 ){
        step+=room_speed
    }else{
        step+=1;
    }
} else if( mainObject3.state != "dead" &amp;&amp; bulletTime==0){
    
    step-= room_speed;
    if(step &lt; 0 )
        step = 0
        
    returningToNormal=1
}



draw_set_blend_mode(bm_normal);
draw_set_alpha(1);

x = view_xview[0];
y = view_yview[0];
w = 320;
h = 240;

xsc = view_wport[0] / view_hview[0];
ysc = view_hport[0] / view_hview[0];

if (spr_srf)
    sprite_delete(spr_srf);




spr_srf = sprite_create_from_surface(application_surface, 0, 0, w, h, false, false, 0, 0);

//draw_sprite( spr_srf, 0, x, y);

//draw_clear(c_black);

col = make_color_rgb(255, 0, 0);
draw_set_color(col);

timeString = string(current_hour) + ":" + string(current_minute) + ":" + string(current_second);

for (i = 0; i &lt; 5; i++) {
    draw_set_alpha(irandom(70) / 300);
    draw_text_transformed(x + 30 + irandom(10), y + 20 + irandom(10), timeString, 1.1, 1.1, 0);
}
draw_set_alpha(1);

draw_text_transformed(x + 30, y + 20, timeString, 1, 1, 0);



time = shader_get_uniform(shd_ripple,"time");
shader_set_uniform_f(time, step);
shader_set(discolor)

if (useflashlight == 0)
    draw_sprite_ext(cameraui, 0, x + irandom(1) - 2, y + irandom(1) - 2, 1, 1, 0, c_red, 0.2)
else
    draw_sprite_ext(cameraui, 0, x + irandom(1) - 2, y + irandom(1) - 2, 1, 1, 0, c_red, 0.4)


if (mainObject3.state == "dead" ){//|| bulletTime==1 || returningToNormal ) {


    for (i = 0; i &lt; step / 100; i++) {
        draw_sprite_ext(spr_srf, 0, x, y, 1 + irandom(i), 1 + irandom(i), 0, c_red, 0.1)
        draw_sprite_ext(spr_srf, 0, x + 1, y + 1, 1 + irandom(i), 1 + irandom(i), 0, c_blue, 0.1)
        draw_sprite_ext(spr_srf, 0, x - 1, y - 1, 1 + irandom(i), 1 + irandom(i), 0, c_green, 0.1)

    }

    //texture_set_interpolation(0);
    if( mainObject3.state == "dead" ){
        timeString = ' press "R" to restart';
        draw_set_font(font1);
        
        
        for (i = 0; i &lt; 5; i++) {
            draw_set_color(c_red);
            draw_set_alpha(irandom(70) / 100);
            draw_text_transformed( mainObject3.x, mainObject3.y, "YOUR DEAD! X", 1.1, 1.1, 0);
        }
    
        
        draw_set_alpha(1);
        draw_set_color(c_blue);
        d3d_transform_set_rotation_z(step/100);
        draw_text_transformed(-2 + view_xview[0], -2 + view_yview[0] + view_hview[0] / 2, timeString, 1, 1, 1);
        draw_set_color(c_green);
         
        draw_text_transformed(-1 + view_xview[0], -1 + view_yview[0] + view_hview[0] / 2, timeString, 1, 1, 1);
        draw_set_color(c_white);
         
        draw_text_transformed(-1 + view_xview[0], view_yview[0] + view_hview[0] / 2, timeString, 1, 1, 1);
        draw_set_font(font1small);
        
        d3d_transform_set_identity();
        //show_debug_message("step is :"+string(step) );
        if( step &lt; 250 ){
            shader_reset();
        }else{
           
        }
    }
} else {

   
    draw_sprite_ext(spr_srf, 0, x, y, 1, 1, 0, c_red, 0.2)
    draw_sprite_ext(spr_srf, 0, x + 1, y + 1, 1, 1, 0, c_blue, 0.2)
    draw_sprite_ext(spr_srf, 0, x - 1, y - 1, 1, 1, 0, c_green, 0.2)
    shader_reset();
    draw_set_alpha(1);
}

 if( bulletTime==1 ){
            var_wave_distortion=(4000);
            //experimental();
            shader_set(shd_ripple);
            //shader_set(videoGlitch);
           
 }else{
    shader_reset();
 }
surface_resize(application_surface, w, h);
//window_set_size(w,h);

      
//wide screen effect
if( focusedOnObject == 0 ){
  draw_set_alpha(1);
    draw_rectangle_color(
    -32 + view_xview[0] ,
    -32 + view_yview[0],
    32 +  view_xview[0] + view_wview[0], 
    32 + view_yview[0] + view_hview[0]/9,
      c_black, c_black, c_black, c_black, false);
   
      draw_rectangle_color(
   -32 + view_xview[0],
   32 + view_yview[0]+view_hview[0],
   32 +  view_xview[0] + view_wview[0], 
     view_yview[0]+ view_hview[0] - (view_hview[0]/7),
      c_black, c_black, c_black, c_black, false);
}

//on the upper side draw the map
draw_map(9);
//down draw the status etc
strbar = "";
if( !focusedOnObject){
    
        strbar=mainObject3.state
}
    draw_set_color(c_red);
    for (i = 0; i &lt; 5; i++) {
        draw_set_alpha(irandom(50) / 300);
        draw_text_transformed(
        32 + view_xview[0]+irandom(2),
   -32 + view_yview[0]+view_hview[0]+irandom(2),
    strbar, 1, 1, 0);
    }
    draw_set_alpha(1);
    draw_set_color(c_red);
      draw_text_transformed(
        32 + view_xview[0],
   -32 + view_yview[0]+view_hview[0],
    strbar, 1.1, 1.1, 0);
    
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
if(useflashlight==0)exit
if(useflashlight==2){
    useflashlight=1;exit
}

depth=4;
 draw_set_alpha(1);
surface_set_target(surf);


draw_clear(c_black);
draw_set_blend_mode(bm_subtract);

pdir = point_direction(mainObject3.x,mainObject3.y,mouse_x,mouse_y)

//shadow caster works
v[0] =  mouse_x - mainObject3.x ;
v[1] = mouse_y - mainObject3.y;
dist = point_distance(v[0], v[1], 0, 0 );

if( dist != 0){
d[0] = v[0]/dist;
d[1] = v[1]/dist;
}

dist+=30;
//flashlight position end
flpoint[0] = mainObject3.x + (d[0]*dist);
flpoint[1] = mainObject3.y + (d[1]*dist);

//find perpendiculars
//v = P2 - P1
//P3 = (-v.y, v.x) / Sqrt(v.x^2 + v.y^2) * h

h=50;
sq=sqrt( (v[0]*v[0]) + (v[1]*v[1]) )
if(sq==0)
sq=1;

p3[0] = (-v[1]/sq*h) + flpoint[0];
p3[1] = (v[0]/sq*h) + flpoint[1];

d3[0] = (-v[1]/sq);
d3[1] = ( v[0]/sq);
//P4 = (-v.y, v.x) / Sqrt(v.x^2 + v.y^2) * -h
h=-50;
p4[0] = (-v[1]/sq*h) + flpoint[0];
p4[1] = (v[0]/sq*h) + flpoint[1];


draw_set_alpha(0.9);
draw_rectangle(flpoint[0],flpoint[1],flpoint[0]+16,flpoint[1]+16,true)
draw_rectangle(p3[0],p3[1],p3[0]+16,p3[1]+16,true)
draw_rectangle(p4[0],p4[1],p4[0]+16,p4[1]+16,true)

draw_set_color(c_green);
draw_primitive_begin(pr_trianglefan);
draw_vertex(mainObject3.x, mainObject3.y);


/*
distp = distance_between_points( p4[0], p4[1], p3[0], p3[1] );
*/

while( abs( p4[0] - p3[0] )!= 0 &amp;&amp;
    abs( p4[1] - p3[1] )!= 0 ){
    
    //old
    lpstep = 4
    p4[0]+=d3[0]*lpstep;
    p4[1]+=d3[1]*lpstep;    
    
    //p4[0]+=d3[0]*lpstep;
    //p4[1]+=d3[1]*lpstep;    
    
    
    c = collision_line_first( mainObject3.x, mainObject3.y, p4[0], p4[1],collidable, true, true);
    if(c){  
        //create rectangle
        rx=c.x;
        ry=c.y;
        rx1=c.x+16;
        ry1=c.y+16;
        //found new d
        v[0] = p4[0] - mainObject3.x;
        v[1] = p4[1] -  mainObject3.y;
        dist = point_distance(v[0], v[1], 0, 0 );
        if( dist != 0){
            d[0] = v[0]/dist;
            d[1] = v[1]/dist;
        }
        
        tp[0] = mainObject3.x;
        tp[1] = mainObject3.y;
        
        cnt=0;
        while( cnt &lt; 300 &amp;&amp; (d[0]!=0 || d[1]!=0) &amp;&amp; !point_in_rectangle(tp[0], tp[1], rx, ry, rx1, ry1) ){
            tp[0]+=(d[0]);
            tp[1]+=(d[1]);
            cnt++;
        }
        //draw_vertex( mainObject3.x + ( px*d[0] ), mainObject3.y + (py*d[1]) );
        if( cnt &lt; 300 )
        draw_vertex( tp[0], tp[1])
        
         //draw_vertex( c.x, c.y);
        //draw_line(mainObject3.x, mainObject3.y, tp[0], tp[1]);
    }else{
        draw_vertex( p4[0], p4[1]);
    }
}

draw_primitive_end();
    

draw_set_alpha(darkness);  
surface_reset_target();

draw_set_blend_mode(bm_normal);

draw_surface( surf, 0, 0);

draw_set_alpha(1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
